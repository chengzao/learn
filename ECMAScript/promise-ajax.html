<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>promise ajax</title>
</head>

<body>
    <h1>Promise</h1>
    <h2>resolve reject : pending（进行中）fulfilled(已成功) rejected（已失败）</h2>
    <h2>Promise.prototype.then</h2>
    <h2>Promise.prototype.catch</h2>
    <h2>Promise.all</h2>
    <h2>Promise.race</h2>
    <h2>Promise.resolve</h2>
    <h2>Promise.reject</h2>
</body>
<script>
    // resolved : pending（进行中） ==> fulfilled（已成功）
    // rejected : pending（进行中） ==> rejected（已失败）
    // 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数
    // 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行
    // Promise 新建后就会立即执行
    // then方法可以接受两个回调函数作为参数 (resolve,reject): reject第二个函数是可选的;返回的是一个新的Promise实例

    function loadImageAsync(url) {
        return new Promise(function (resolve, reject) {
            let image = new Image();
            image.onload = function () {
                resolve()
            }
            image.onerror = function () {
                reject(new Error('Could not load image at ' + url))
            }
            image.src = url;
        });
    }

    var getJSON = function (url) {
        var promise = new Promise(function (resolve, reject) {
            var client = new XMLHttpRequest();
            client.open("GET", url);
            client.onreadystatechange = handler;
            client.responseType = "json";
            client.setRequestHeader("Accept", "application/json");
            client.send();

            function handler() {
                if (this.readyState !== 4) {
                    return;
                }
                if (this.status === 200) {
                    resolve(this.response);
                } else {
                    reject(new Error(this.statusText));
                }
            };
        })
        return promise;
    }

    getJSON("/a.json").then(function (json) {
        console.log('Contents: ' + json);
    }, function (error) {
        console.error('出错了', error);
    });

    getJSON("/post/1.json").then(
        post => getJSON(post.commentURL)
    ).then(
        comments => console.log("resolved: ", comments),
        err => console.log("rejected: ", err)
    );

    // catch : 用于指定发生错误时的回调函数 (相当于.then(null, rejection));返回的是一个 Promise 对象
    // 如果 Promise 状态已经变成resolved，再抛出错误是无效的
    const promise = new Promise(function (resolve, reject) {
        resolve('ok');
        throw new Error('test');
    });
    promise
        .then(function (value) {
            console.log(value)
        })
        .catch(function (error) {
            console.log(error)
        });
    // ok

    // Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获

    // 一般不在.then方法里定义reject状态的回调函数，在最后使用.catch方法
    p.then((val) => console.log('fulfilled:', val))
        .catch((err) => console.log('rejected', err));

    // 等同于
    p.then((val) => console.log('fulfilled:', val))
        .then(null, (err) => console.log("rejected:", err));


    getJSON('/post/1.json').then(function (post) {
        return getJSON(post.commentURL);
    }).then(function (comments) {
        // some code
    }).catch(function (error) {
        // 处理前面三个Promise产生的错误
    });

    // 如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应
    const someAsyncThing = function () {
        return new Promise(function (resolve, reject) {
            // 下面一行会报错，因为x没有声明
            resolve(x + 2);
        });
    };

    someAsyncThing().then(function () {
        console.log('everything is great');
    });

    setTimeout(() => {
        console.log(123)
    }, 2000);
    // Uncaught (in promise) ReferenceError: x is not defined
    // 123

    // 浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”


    // Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例
    // Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例
    const p = Promise.all([p1, p2, p3]);
    // 只有当所有的状态都为fulfieled，p的状态才会变成reject；否则p的状态变为reject；最后才传递给p的回调函数
    // 当如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法
    const p1 = new Promise((resolve, reject) => {
        resolve('hello');
    })
        .then(result => result)
        .catch(e => e);

    // p2 定义了catch方法
    const p2 = new Promise((resolve, reject) => {
        throw new Error('报错了');
    })
        .then(result => result)
        .catch(e => e);

    Promise.all([p1, p2])
        .then(result => console.log(result))
        .catch(e => console.log(e));
    // ["hello", Error: 报错了]


    // Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例
    const p = Promise.race([p1, p2, p3]);
    // 只要其中有一个实例改变，p的状态就改变，并传递给p的回调函数


    // Promise.resolve 将现有对象转为 Promise 对象
    Promise.resolve('foo')
    // 等价于
    new Promise(resolve => resolve('foo'))

    // （1）参数是一个 Promise 实例: 直接返回这个实例
    // （1）参数是一个 thenable 对象: 将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。
    let thenable = {
        then: function (resolve, reject) {
            resolve(42);
        }
    };

    let p1 = Promise.resolve(thenable);
    p1.then(function (value) {
        console.log(value); // 42
    });
    // （3）参数不是具有then方法的对象，或根本就不是对象：如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved
    const p = Promise.resolve('Hello');

    p.then(function (s) {
        console.log(s)
    });
    // Hello

    // （4）不带有任何参数：允许调用时不带参数，直接返回一个resolved状态的 Promise 对象
    const p = Promise.resolve();

    p.then(function () {
        // ...
    });

    // 需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时
    setTimeout(function () {
        console.log('three');
    }, 0);

    Promise.resolve().then(function () {
        console.log('two');
    });

    console.log('one');
    // one
    // two
    // three


    // Promise.reject : 会返回一个新的 Promise 实例，该实例的状态为rejected
    const p = Promise.reject('出错了');
    // 等同于
    const p = new Promise((resolve, reject) => reject('出错了'))

    p.then(null, function (s) {
        console.log(s)
    });
    // 出错了

    //注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数
    const thenable = {
        then(resolve, reject) {
            reject('出错了');
        }
    };

    Promise.reject(thenable)
        .catch(e => {
            console.log(e === thenable)
        })
    // true


    // 附加方法
    // 1. done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误
    Promise.prototype.done = function (onFulfilled, onRejected) {
        this.then(onFulfilled, onRejected)
            .catch(function (reason) {
                // 抛出一个全局错误
                setTimeout(() => { throw reason }, 0);
            });
    };

    //2. finally方法,用于指定不管 Promise 对象最后状态如何，都会执行的操作;可接受一个普通的回调函数作为参数，该函数不管怎样都必须执行
    Promise.prototype.finally = function (callback) {
        let P = this.constructor;
        return this.then(
            value => P.resolve(callback()).then(() => value),
            reason => P.resolve(callback()).then(() => { throw reason })
        );
    };


    // 应用
    // 1.0 加载图片
    const preloadImage = function (path) {
        return new Promise(function (resolve, reject) {
            const image = new Image();
            image.onload = resolve;
            image.onerror = reject;
            image.src = path;
        });
    };

    // Generator 函数与 Promise 的结合
    // 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象
    function getFoo() {
        return new Promise(function (resolve, reject) {
            resolve('foo');
        });
    }

    const g = function* () {
        try {
            const foo = yield getFoo();
            console.log(foo);
        } catch (e) {
            console.log(e);
        }
    };

    function run(generator) {
        const it = generator();

        function go(result) {
            if (result.done) return result.value;
            return result.value.then(function (value) {
                return go(it.next(value));
            }, function (error) {
                return go(it.throw(error));
            });
        }
        go(it.next());
    }
    run(g);


    //
    const f = () => console.log('now');
    (
        () => new Promise(
            resolve => resolve(f())
        )
    )();
    console.log('next');
    // now
    // next
</script>

</html>