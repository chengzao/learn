<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>object</title>
</head>

<body>
    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"> Object TO URL </a>
</body>
<script type="text/javascript">
    let name = 'zhansan',
        age = 20;
    let obj = {
        name,
        age,
        say() {
            console.log(this.name);
        }
    }
    console.log(obj.age);
    obj.say();



    // Object.is()
    console.log(NaN == NaN); // ==> false
    console.log(-0 == +0); // ==> true
    console.log(Object.is(NaN, NaN)); // ==> true
    console.log(Object.is(-0, +0)); // ==> false

    // Object.assign()

    let obj2 = {};

    Object.assign(obj2, {
        'name': 'xiaowang'
    });

    console.log(obj2); // {'name':'xiaowang'}


    // Object.create()

    let breakfast = {
        getDrink() {
            return 'tea';
        }
    }

    let dinner = {
        getDrink() {
            return 'beer'
        }
    }
    let sunday = Object.create(breakfast);
    console.log(sunday.getDrink()); // tea
    console.log(Object.getPrototypeOf(sunday) === breakfast) // true

    Object.setPrototypeOf(sunday, dinner);
    console.log(sunday.getDrink()); // beer
    console.log(Object.getPrototypeOf(sunday) === dinner) // true

    // __proto_

    let saturday = {
        __proto__: breakfast
    }
    console.log(saturday.getDrink()); // tea
    console.log(Object.getPrototypeOf(saturday) === breakfast); //true

    saturday.__proto__ = dinner;
    console.log(saturday.getDrink()); // beer
    console.log(Object.getPrototypeOf(saturday) == dinner); //true

    // super

    let friday = {
        __proto__: breakfast,
        getDrink() {
            return super.getDrink() + ' beer';
        }
    }

    console.log(friday.getDrink());


    // 输出对象自身可以枚举的值
    var obj = {
        'name': 'zhangsan',
        'age': 10
    };

    for (var key of Object.keys(obj)) {
        console.log(key + ": " + obj[key]);
    }



    const foo = 'bar';
    const baz = {
        foo
    };
    baz // {foo: "bar"}


    // 属性名表达式
    // 方法一
    obj.foo = true;

    // 方法二
    obj['a' + 'bc'] = 123;


    let lastWord = 'last word';

    const a = {
        'first word': 'hello',
        [lastWord]: 'world'
    };

    a['first word'] // "hello"
    a[lastWord] // "world"
    a['last word'] // "world"

    let obj = {
        ['h' + 'ello']() {
            return 'hi';
        }
    };

    obj.hello() // hi


    // 获取getter和setter的函数名

    const obj = {
        get foo() {},
        set foo(x) {}
    };
    const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');
    descriptor.get.name // "get foo"
    descriptor.set.name // "set foo"

    (new Function()).name // "anonymous"

    var doSomething = function () {
        // ...
    };
    doSomething.bind().name // "bound doSomething"


    const key1 = Symbol('description');
    const key2 = Symbol();
    let obj = {
        [key1]() {},
        [key2]() {},
    };
    obj[key1].name // "[description]"
    obj[key2].name // ""


    // Object.is 它用来比较两个值是否严格相等

    Object.is('foo', 'foo') // true
    Object.is({}, {}) // false

        +
        0 === -0 //true
    NaN === NaN // false

    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true

    Object.defineProperty(Object, 'is', {
        value: function (x, y) {
            if (x === y) {
                // 针对+0 不等于 -0的情况
                return x !== 0 || 1 / x === 1 / y;
            }
            // 针对NaN的情况
            return x !== x && y !== y;
        },
        configurable: true,
        enumerable: false,
        writable: true
    });


    // Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）
    // Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。
    // 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错
    // 如果undefined和null不在首参数，就不会报错。
    // Object.assign 浅拷贝方式
    Object.assign(undefined) // 报错
    Object.assign(null) // 报错
    let obj = {
        a: 1
    };
    Object.assign(obj, undefined) === obj // true
    Object.assign(obj, null) === obj // true

    //为对象添加属性
    class Point {
        constructor(x, y) {
            Object.assign(this, {
                x,
                y
            });
        }
    }
    //为对象添加方法
    Object.assign(SomeClass.prototype, {
        someMethod(arg1, arg2) {},
        anotherMethod() {}
    });
    // 等同于下面的写法
    SomeClass.prototype.someMethod = function (arg1, arg2) {};
    SomeClass.prototype.anotherMethod = function () {};

    //克隆对象
    function clone(origin) {
        return Object.assign({}, origin);
    }

    function clone(origin) {
        let originProto = Object.getPrototypeOf(origin);
        return Object.assign(Object.create(originProto), origin);
    }

    // 合并多个对象
    const merge = (target, ...sources) => Object.assign(target, ...sources);

    // 属性的可枚举行
    // Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象
    // 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性
    let obj = {
        foo: 123
    };
    Object.getOwnPropertyDescriptor(obj, 'foo')


    // for...in循环：只遍历对象自身的和继承的可枚举的属性。
    // Object.keys()：返回对象自身的所有可枚举的属性的键名。
    // JSON.stringify()：只串行化对象自身的可枚举的属性。
    // Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
    // ES6 规定，所有 Class 的原型的方法都是不可枚举的。
    // 尽量不要用for...in循环，而用Object.keys()代替


    // 属性的遍历

    // for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）
    // Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名
    // Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名
    // Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
    // Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举
    //


    // Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象（descriptor）
    const obj = {
        foo: 123,
        get bar() {
            return 'abc'
        }
    };

    Object.getOwnPropertyDescriptors(obj)

    // super 指向当前对象的原型对象
    const proto = {
        foo: 'hello'
    };

    const obj = {
        find() {
            return super.foo;
        }
    };

    Object.setPrototypeOf(obj, proto);
    obj.find() // "hello"

    // Object.setPrototypeOf方法，用于读取一个对象的原型对象
    // Object.setPrototypeOf方法，用来设置一个对象的prototype对象，返回参数对象本身

    // Object.keys方法，返回一个数组,参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名
    // Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值
    // Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组

    // 冻结
    var immutableState = Object.freeze({
        minimum: 21
    });
    console.log(immutableState)
</script>

</html>