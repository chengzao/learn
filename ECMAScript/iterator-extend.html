<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>iterator</title>
</head>

<body>
    <h1>iterator:遍历器</h1>
    <h2>JavaScript表示“集合”的数据结构:Array Object Set Map</h2>
    <h2>next(), return(), throw() </h2>
</body>
<script>
    /*
        Iterator 的遍历过程是这样的。

        （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

        （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。

        （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。

        （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。

        每一次调用next方法，都会返回数据结构的当前成员的信息。
        具体来说，就是返回一个包含value和done两个属性的对象。
        其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束

        */

    var it = idMaker();

    console.log(it.next().value) // '0'
    console.log(it.next().value) // '1'
    console.log(it.next().value) // '2'

    function idMaker() {
        var index = 0;

        return {
            next: function () {
                return { value: index++, done: false };
            }
        };
    }

    //Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器

    /* 原生具备 Iterator 接口的数据结构
        Array , Map , Set , String , TypedArray , arguments , NodeList
     */
    let arr = ['a', 'b', 'c'];
    let iter = arr[Symbol.iterator]();

    console.log(iter.next()) // { value: 'a', done: false }
    console.log(iter.next()) // { value: 'b', done: false }
    console.log(iter.next()) // { value: 'c', done: false }
    console.log(iter.next()) // { value: undefined, done: true }


    class RangeIterator {
        constructor(start, stop) {
            this.value = start;
            this.stop = stop;
        }

        [Symbol.iterator]() { return this; }

        next() {
            var value = this.value;
            if (value < this.stop) {
                this.value++;
                return { done: false, value: value };
            }
            return { done: true, value: undefined };
        }
    }

    function range(start, stop) {
        return new RangeIterator(start, stop);
    }

    for (var value of range(0, 3)) {
        console.log(value); // 0, 1, 2
    }

    // 构造函数的原型链上部署Symbol.iterator方法
    function Obj(value) {
        this.value = value;
        this.next = null;
    }

    Obj.prototype[Symbol.iterator] = function () {
        var iterator = { next: next };

        var current = this;

        function next() {
            if (current) {
                var value = current.value;
                current = current.next;
                return { done: false, value: value };
            } else {
                return { done: true };
            }
        }
        return iterator;
    }

    var one = new Obj(1);
    var two = new Obj(2);
    var three = new Obj(3);

    one.next = two;
    two.next = three;

    for (var i of one) {
        console.log(i); // 1, 2, 3
    }


    // 为对象添加 Iterator 接口的例子
    let obj = {
        data: ['hello', 'world'],
        [Symbol.iterator]() {
            const self = this;
            let index = 0;
            return {
                next() {
                    if (index < self.data.length) {
                        return {
                            value: self.data[index++],
                            done: false
                        };
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
        }
    };
    let bbb = obj[Symbol.iterator]()
    console.log(bbb.next()); //{value: "hello", done: false}
    console.log(bbb.next()); //{value: "world", done: false}


    // 对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口
    NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
    // 或者
    NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];

    [...document.querySelectorAll('div')] // 可以执行了
    // 类似数组的对象
    let iterable = {
        0: 'a',
        1: 'b',
        2: 'c',
        length: 3,
        [Symbol.iterator]: Array.prototype[Symbol.iterator]
    };
    for (let item of iterable) {
        console.log(item); // 'a', 'b', 'c'
    }

    // 注意，普通对象部署数组的Symbol.iterator方法，并无效果
    let iterable = {
        a: 'a',
        b: 'b',
        c: 'c',
        length: 3,
        [Symbol.iterator]: Array.prototype[Symbol.iterator]
    };
    for (let item of iterable) {
        console.log(item); // undefined, undefined, undefined
    }


    // 调用 Iterator 接口的场合 
    // （1）解构赋值:对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法
    let set = new Set().add('a').add('b').add('c');

    let [x, y] = set;
    // x='a'; y='b'

    let [first, ...rest] = set;
    // first='a'; rest=['b','c'];

    // （2）扩展运算符:扩展运算符（...）也会调用默认的 Iterator 接口
    // 例一
    var str = 'hello';
    [...str] //  ['h','e','l','l','o']

    // 例二
    let arr = ['b', 'c'];
    ['a', ...arr, 'd']
    // ['a', 'b', 'c', 'd']

    // 可以将任何部署了 Iterator 接口的数据结构，转为数组
    let arr = [...iterable];


    // （3）yield* :yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口
    let generator = function* () {
        yield 1;
        yield* [2, 3, 4];
        yield 5;
    };

    var iterator = generator();

    iterator.next() // { value: 1, done: false }
    iterator.next() // { value: 2, done: false }
    iterator.next() // { value: 3, done: false }
    iterator.next() // { value: 4, done: false }
    iterator.next() // { value: 5, done: false }
    iterator.next() // { value: undefined, done: true }

    // （4）其他场合:由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口
    // for...of , Array.from(), Map(), Set(), WeakMap(), WeakSet() 比如new Map([['a',1],['b',2]])）
    // Promise.all(), Promise.race()


    // 字符串的 Iterator 接口
    var someString = "hi";
    typeof someString[Symbol.iterator]
    // "function"

    var iterator = someString[Symbol.iterator]();

    iterator.next() // { value: "h", done: false }
    iterator.next() // { value: "i", done: false }
    iterator.next() // { value: undefined, done: true }

    // Iterator 接口与 Generator 函数 
    var myIterable = {};

    myIterable[Symbol.iterator] = function* () {
        yield 1;
        yield 2;
        yield 3;
    };
    [...myIterable] // [1, 2, 3]

    // 或者采用下面的简洁写法

    let obj = {
        * [Symbol.iterator]() {
            yield 'hello';
            yield 'world';
        }
    };

    for (let x of obj) {
        console.log(x);
    }
    // hello
    // world


    // 遍历器对象的 return()，throw()

    // return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。
    // 如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法
    function readLinesSync(file) {
        return {
            next() {
                return { done: false };
            },
            return () {
                file.close();
                return { done: true };
            },
        };
    }
    // 下面的三种情况，都会触发执行return方法
    //注意，return方法必须返回一个对象，这是 Generator 规格决定的
    // 情况一
    for (let line of readLinesSync(fileName)) {
        console.log(line);
        break;
    }

    // 情况二
    for (let line of readLinesSync(fileName)) {
        console.log(line);
        continue;
    }

    // 情况三
    for (let line of readLinesSync(fileName)) {
        console.log(line);
        throw new Error();
    }
</script>

</html>