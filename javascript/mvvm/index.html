<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>self-vue</title>
</head>
<style>
  #app {
    text-align: center;
  }
</style>
<body>
  <div id="app">
    <h2>{{title}}</h2>
    <input v-model="name">
    <h1>{{name}}</h1>
    <button v-on:click="clickMe">click me!</button>
  </div>
</body>
<script src="js/observer.js"></script>
<script src="js/watcher.js"></script>
<script src="js/compile.js"></script>
<script src="js/index.js"></script>
<script type="text/javascript">
  //原文链接：http://www.cnblogs.com/canfoo/p/6891868.html
  //Object.defineProperty:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
  /**
   * 实现数据的双向绑定，
   * 首先要对数据进行劫持监听，
   * 所以我们需要设置一个监听器Observer，用来监听所有属性。
   * 如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。
   * 因为订阅者是有很多个，
   * 所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，
   * 然后在监听器Observer和订阅者Watcher之间进行统一管理的。
   * 接着，我们还需要有一个指令解析器Compile，
   * 对每个节点元素进行扫描和解析，
   * 将相关指令对应初始化成一个订阅者Watcher，
   * 并替换模板数据或者绑定相应的函数，
   * 此时当订阅者Watcher接收到相应属性的变化，
   * 就会执行对应的更新函数，
   * 从而更新视图。
  */
  /**
   * 监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
   * 订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
   * 解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。
   * 消息订阅器Dep, 来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。
  */
  new SelfVue({
    el: '#app',
    data: {
      title: 'hello world',
      name: 'canfoo'
    },
    methods: {
      clickMe: function () {
        this.title = 'hello world';
      }
    },
    mounted: function () {
      window.setTimeout(() => {
        this.title = '你好';
      }, 1000);
    }
  });
</script>
</html>