<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>数组快速排序</title>
</head>

<body>

</body>
<script>
  function quickSort(arr) {
    //如果数组长度<=1,则直接返回
    if (arr.length <= 1) {
      return arr;
    }
    // 中间位(基准)取长度的一半向下取整
    var pivotIndex = Math.floor(arr.length / 2);
    //把中间位从原数组切割出来, splice 会改变原数组!!!!
    var pivot = arr.splice(pivotIndex, 1)[0];

    //console.log('arr',arr,'pivotIndex',pivotIndex,'pivot',pivot);

    //定义两个空数组来存放比对后的值
    var left = [];
    var right = [];

    //比基准小的放在left，比基准大的放在right
    for (var i = 0, j = arr.length; i < j; i++) {
      if (arr[i] <= pivot) {
        left.push(arr[i]);
      } else {
        right.push(arr[i]);
      }
    }

    //console.log('left',...left,'pivot',pivot,'right',...right);

    //递归下去  arr = [ left , pivot , right]
    // 怎么个递归法,就是比对后的数组还是会重复之前的取基准再切开比较..直到最后没有可以切了
    return quickSort(left).concat([pivot], quickSort(right));
  }


  var _arr = quickSort([1, 34, 5, 6, 7, 23, 1, 33])
  console.log('_arr', _arr);


  function bubbleSort2(arr) {
    console.time('改进后冒泡排序耗时');
    var i = arr.length - 1; //初始时,最后位置保持不变
    while (i > 0) {
      var pos = 0; //每趟开始时,无记录交换
      for (var j = 0; j < i; j++)
        console.log(arr[j], arr[j + 1])
      if (arr[j] > arr[j + 1]) {
        pos = j; //记录交换的位置
        var tmp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tmp;
      }
      i = pos; //为下一趟排序作准备
    }
    console.timeEnd('改进后冒泡排序耗时');
    return arr;
  }
  var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
  console.log(bubbleSort2(arr));
</script>

</html>