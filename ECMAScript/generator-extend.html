<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>generator</title>
</head>

<body>
    <h1>generator</h1>
    <h2>callback</h2>
    <h2>promise</h2>
    <h2>async</h2>
</body>
<script>
    // Generator 函数两个特征 : function关键字与函数名之间有一个星号;函数体内部使用yield表达式，定义不同的内部状态
    // 执行 Generator 函数会返回一个遍历器对象
    // yield表达式是暂停执行的标记，而next方法可以恢复执行
    // 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针
    // value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束
    function* helloWorldGenerator() {
        yield 'hello';
        yield 'world';
        return 'ending';
    }

    var hw = helloWorldGenerator();
    hw.next() // { value: 'hello', done: false }
    hw.next() // { value: 'world', done: false }
    hw.next() // { value: 'ending', done: true }
    hw.next() // { value: undefined, done: true }

    // 遍历器对象的next方法的运行
    // （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。
    // （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。
    // （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。
    // （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。

    // next：返回yield后的值
    // Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数
    // yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。
    function* f() {
        console.log('执行了！')
    }

    var generator = f();

    setTimeout(function () {
        generator.next()
    }, 2000);


    // 句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield表达式
    var arr = [1, [
        [2, 3], 4
    ],
        [5, 6]
    ];

    var flat = function* (a) {
        a.forEach(function (item) {
            if (typeof item !== 'number') {
                yield * flat(item);
            } else {
                yield item;
            }
        });
    };

    for (var f of flat(arr)) {
        console.log(f);
    }

    // 修改方法是改用for循环
    var arr = [1, [
        [2, 3], 4
    ],
        [5, 6]
    ];

    var flat = function* (a) {
        var length = a.length;
        for (var i = 0; i < length; i++) {
            var item = a[i];
            if (typeof item !== 'number') {
                yield* flat(item);
            } else {
                yield item;
            }
        }
    };

    for (var f of flat(arr)) {
        console.log(f);
    }
    // 1, 2, 3, 4, 5, 6

    // yield表达式如果用在另一个表达式之中，必须放在圆括号里面
    function* demo() {
        console.log('Hello' + yield); // SyntaxError
        console.log('Hello' + yield 123); // SyntaxError

        console.log('Hello' + (yield)); // OK
        console.log('Hello' + (yield 123)); // OK
    }
    // yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号
    function* demo() {
        foo(yield 'a', yield 'b'); // OK
        let input = yield; // OK
    }


    // 与 Iterator 接口的关系
    // 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口
    var myIterable = {};
    myIterable[Symbol.iterator] = function* () {
        yield 1;
        yield 2;
        yield 3;
    };

    [...myIterable] // [1, 2, 3]

    // Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身
    function* gen() {
        // some code
    }

    var g = gen();

    g[Symbol.iterator]() === g // true

    // next 方法的参数
    // next方法可以带一个参数，该参数就会被当作上一个 yield表达式的返回值
    function* foo(x) {
        var y = 2 * (yield (x + 1));
        var z = yield (y / 3);
        return (x + y + z);
    }

    var a = foo(5);
    // (5 + 1) = 6
    a.next() // Object{value:6, done:false}
    // ( 2 * undefined ) / 3 = NaN
    a.next() // Object{value:NaN, done:false}
    // 5 + NaN + undefined = NaN
    a.next() // Object{value:NaN, done:true}

    //在第一次使用next方法时，传递参数是无效的
    var b = foo(5);
    // ( 5 +1 ) = 6
    b.next(666) // { value:6, done:false }
    // ( 2 * 12 ) / 3  = 8
    b.next(12) // { value:8, done:false }
    // x = 5 ; y = 24 ; z = 13
    // 5 + ( 2 * 12 ) + 13 = 42
    b.next(13) // { value:42, done:true }


    function* dataConsumer() {
        console.log('Started');
        console.log(`1. ${yield}`);
        console.log(`2. ${yield}`);
        return 'result';
    }

    let genObj = dataConsumer();
    genObj.next(); // Started
    genObj.next('a') // 1. a
    genObj.next('b') // 2. b

    // 第一次调用next方法时，就能够输入值
    function wrapper(generatorFunction) {
        return function (...args) {
            let generatorObject = generatorFunction(...args);
            generatorObject.next();
            return generatorObject;
        };
    }

    const wrapped = wrapper(function* () {
        console.log(`First input: ${yield}`);
        return 'DONE';
    });

    wrapped().next('hello!') // First input: hello!

    // for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法
    function* foo() {
        yield 1;
        yield 2;
        return 3;
    }

    for (let v of foo()) {
        console.log(v);
    }
    // 1 2 3


    // for of 遍历任意对象（object）的方法
    function* objectEntries(obj) {
        let propKeys = Reflect.ownKeys(obj);

        for (let propKey of propKeys) {
            yield [propKey, obj[propKey]];
        }
    }

    let jane = { first: 'Jane', last: 'Doe' };

    for (let [key, value] of objectEntries(jane)) {
        console.log(`${key}: ${value}`);
    }

    //
    function* numbers() {
        yield 1
        yield 2
        return 3
        yield 4
    }

    // 扩展运算符
    [...numbers()] // [1, 2]

    // Array.from 方法
    Array.from(numbers()) // [1, 2]

    // 解构赋值
    let [x, y] = numbers();
    x // 1
    y // 2

    // for...of 循环
    for (let n of numbers()) {
        console.log(n)
    }
    // 1
    // 2

    //throw : Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获
    var g = function* () {
        try {
            yield;
        } catch (e) {
            console.log('内部中：', e);
        }
    };

    var i = g();
    i.next();
    i.throw(new Error('出错了！'));
    // 内部中： Error: 出错了！


    //
    var gen = function* gen() {
        try {
            yield console.log('a');
        } catch (e) {
            // console.log('内部中：',e);
        }
        yield console.log('b');
        yield console.log('c');
    }

    var g = gen();
    g.next() // a
    g.throw() // b
    g.next() // c

    //throw命令抛出的错误不会影响到遍历器的状态
    //Generator 函数体外抛出的错误，可以在函数体内捕获；
    //Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。
    //Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了


    function* g() {
        yield 1;
        console.log('throwing an exception');
        throw new Error('generator broke!');
        yield 2;
        yield 3;
    }

    function log(generator) {
        var v;
        console.log('starting generator');
        try {
            v = generator.next();
            console.log('第一次运行next方法', v);
        } catch (err) {
            console.log('捕捉错误', v);
        }
        try {
            v = generator.next();
            console.log('第二次运行next方法', v);
        } catch (err) {
            console.log('捕捉错误', v);
        }
        try {
            v = generator.next();
            console.log('第三次运行next方法', v);
        } catch (err) {
            console.log('捕捉错误', v);
        }
        console.log('caller done');
    }

    log(g());
    // starting generator
    // 第一次运行next方法 { value: 1, done: false }
    // throwing an exception
    // 捕捉错误 { value: 1, done: false }
    // 第三次运行next方法 { value: undefined, done: true }
    // caller done

    // return :Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数
    // 如果return方法调用时，不提供参数，则返回值的value属性为undefined
    // 如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。
    function* gen() {
        yield 1;
        yield 2;
        yield 3;
    }

    var g = gen();

    g.next() // { value: 1, done: false }
    g.return('foo') // { value: "foo", done: true }
    g.next() // { value: undefined, done: true }


    // yeild* : 用来在一个 Generator 函数里面执行另一个 Generator 函数
    function* bar() {
        yield 'x';
        yield* foo();
        yield 'y';
    }
    // 等同于
    function* bar() {
        yield 'x';
        for (let v of foo()) {
            yield v;
        }
        yield 'y';
    }

    let delegatedIterator = (function* () {
        yield 'Hello!';
        yield 'Bye!';
    }());

    let delegatingIterator = (function* () {
        yield 'Greetings!';
        yield* delegatedIterator;
        yield 'Ok, bye.';
    }());

    for (let value of delegatingIterator) {
        console.log(value);
    }


    // yield* : 后面的 Generator 函数（没有return语句时）
    function* concat(iter1, iter2) {
        yield* iter1;
        yield* iter2;
    }

    // yield* : 后面的 Generator 函数（有return语句时）
    function* foo() {
        yield 2;
        yield 3;
        return "foo";
    }

    function* bar() {
        yield 1;
        var v = yield* foo();
        console.log("v: " + v);
        yield 4;
    }

    var it = bar();

    // 任何数据结构只要有 Iterator 接口，就可以被yield*遍历
    function* gen() {
        yield* ["a", "b", "c"];
    }

    gen().next() // { value:"a", done:false }

    let read = (function* () {
        yield 'hello';
        yield* 'hello';
    })();

    read.next().value // "hello"
    read.next().value // "h"

    // yield*命令可以很方便地取出嵌套数组的所有成员
    function* iterTree(tree) {
        if (Array.isArray(tree)) {
            for (let i = 0; i < tree.length; i++) {
                yield* iterTree(tree[i]);
            }
        } else {
            yield tree;
        }
    }

    const tree = ['a', ['b', 'c'],
        ['d', 'e']
    ];

    for (let x of iterTree(tree)) {
        console.log(x);
    }

    // 作为对象属性的 Generator 函数

    let obj = {
        myGeneratorMethod: function* () {
            // ···
        }
    };
    // (简写)
    let obj = {
        * myGeneratorMethod() { }
    };

    // Generator 函数的this
    function* g() { }

    g.prototype.hello = function () {
        return 'hi!';
    };

    let obj = g();

    obj instanceof g // true
    obj.hello() // 'hi!'


    function* g() {
        this.a = 11;
    }

    let obj = g();
    obj.a // undefined

    // Generator 函数也不能跟new命令一起用，会报错

    function* F() {
        yield this.x = 2;
        yield this.y = 3;
    }

    new F() // TypeError: F is not a constructor


    // generator 的 this 使用
    function* F() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
    }
    var obj = {};
    var f = F.call(obj); //obj

    f.next(); // Object {value: 2, done: false}
    f.next(); // Object {value: 3, done: false}
    f.next(); // Object {value: undefined, done: true}

    obj.a // 1
    obj.b // 2
    obj.c // 3

    function* F() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
    }
    var f = F.call(F.prototype); // prototype

    f.next(); // Object {value: 2, done: false}
    f.next(); // Object {value: 3, done: false}
    f.next(); // Object {value: undefined, done: true}

    f.a // 1
    f.b // 2
    f.c // 3

    // new
    function* gen() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
    }

    function F() {
        return gen.call(gen.prototype);
    }

    var f = new F();

    f.next(); // Object {value: 2, done: false}
    f.next(); // Object {value: 3, done: false}
    f.next(); // Object {value: undefined, done: true}

    f.a // 1
    f.b // 2
    f.c // 3

    //generator应用
    // 在任意对象上部署 Iterator 接口
    function* iterEntries(obj) {
        let keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            yield [key, obj[key]];
        }
    }

    let myObj = { foo: 3, bar: 7 };

    for (let [key, value] of iterEntries(myObj)) {
        console.log(key, value);
    }

    //callback
    // nodejs
    fs.readFile('/etc/passwd', 'utf-8', function (err, data) {
        if (err) throw err;
        console.log(data);
    });
    // promise
    var readFile = require('fs-readfile-promise');

    readFile(fileA)
        .then(function (data) {
            console.log(data.toString());
        })
        .then(function () {
            return readFile(fileB);
        })
        .then(function (data) {
            console.log(data.toString());
        })
        .catch(function (err) {
            console.log(err);
        });
    // generator
    function* asyncJob() {
        // ...其他代码
        var f = yield readFile(fileA);
        // ...其他代码
    }

    // 异步任务的封装

    var fetch = require('node-fetch');
    var fs = require('fs');

    function* gen() {
        try {
            var url = 'https://api.github.com/users/chengzao';
            var result = yield fetch(url);
            var res = yield result.json();
            var url2 = yield fetch(res.subscriptions_url);
            var res2 = yield url2.json();
            var ddd = JSON.stringify(res2)
            fs.writeFile('res2.json', ddd, err => {
                if (err) {
                    console.log(err);
                }
            });
        } catch (error) {
            console('error is : ', error);
        }
    }

    var run = function (g) {
        var it = g();

        function go(result) {
            if (result.done) {
                return result.value;
            }
            return result.value.then(function (value) {
                return go(it.next(value));
            }, function (err) {
                return go(it.throw(value));
            });
        }
        go(it.next());
    };

    run(gen);


    // 2
    function* main() {
        var result = yield request("http://www.filltext.com?rows=10&f={firstName}");
        console.log(result);
    }

    function request(url) {
        var r = new XMLHttpRequest();
        r.open("GET", url, true);
        r.onreadystatechange = function () {
            if (r.readyState != 4 || r.status != 200) return;
            var data = JSON.parse(r.responseText);
            it.next(data);
        };
        r.send();
    }
    var it = main();
    it.next();

    // thunk
    // ES5版本
    var Thunk = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return function (callback) {
                args.push(callback);
                return fn.apply(this, args);
            }
        };
    };

    // ES6版本
    const Thunk = function (fn) {
        return function (...args) {
            return function (callback) {
                return fn.call(this, ...args, callback);
            }
        };
    };



    // promise readfile

    var fs = require('fs');

    var readFile = function (fileName) {
        return new Promise(function (resolve, reject) {
            fs.readFile(fileName, function (error, data) {
                if (error) return reject(error);
                resolve(data);
            });
        });
    };

    var gen = function* () {
        var f1 = yield readFile('/etc/paths');
        var f2 = yield readFile('/etc/hosts');
        console.log(f1.toString());
        console.log(f2.toString());
    };

    function run(gen) {
        var g = gen();

        function next(data) {
            var result = g.next(data);
            if (result.done) return result.value;
            result.value.then(function (data) {
                next(data);
            });
        }
        next();
    }

    run(gen);
</script>

</html>