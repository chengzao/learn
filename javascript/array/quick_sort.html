<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>数组快速排序</title>
</head>

<body>

</body>
<script>
    function quickSort(arr) {
        //如果数组长度<=1,则直接返回
        if (arr.length <= 1) {
            return arr;
        }
        // 中间位(基准)取长度的一半向下取整
        var pivotIndex = Math.floor(arr.length / 2);
        //把中间位从原数组切割出来, splice 会改变原数组!!!!
        var pivot = arr.splice(pivotIndex, 1)[0];

        //console.log('arr',arr,'pivotIndex',pivotIndex,'pivot',pivot);

        //定义两个空数组来存放比对后的值
        var left = [];
        var right = [];

        //比基准小的放在left，比基准大的放在right
        for (var i = 0, j = arr.length; i < j; i++) {
            if (arr[i] <= pivot) {
                left.push(arr[i]);
            } else {
                right.push(arr[i]);
            }
        }

        //console.log('left',...left,'pivot',pivot,'right',...right);

        //递归下去  arr = [ left , pivot , right]
        // 怎么个递归法,就是比对后的数组还是会重复之前的取基准再切开比较..直到最后没有可以切了
        return quickSort(left).concat([pivot], quickSort(right));
    }


    var _arr = quickSort([1, 34, 5, 6, 7, 23, 1, 33])
    console.log('_arr', _arr);


    function bubbleSort2(arr) {
        console.time('改进后冒泡排序耗时');
        var i = arr.length - 1; //初始时,最后位置保持不变
        while (i > 0) {
            var pos = 0; //每趟开始时,无记录交换
            for (var j = 0; j < i; j++)
                console.log(arr[j],arr[j+1])
                if (arr[j] > arr[j + 1]) {
                    pos = j; //记录交换的位置
                    var tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                }
            i = pos; //为下一趟排序作准备
        }
        console.timeEnd('改进后冒泡排序耗时');
        return arr;
    }
    var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
    console.log(bubbleSort2(arr));
</script>

</html>