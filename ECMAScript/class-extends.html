<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>class extend</title>
</head>

<body>

</body>
<script>
    function Foo(name) {
        this.name = name;
    }

    Foo.prototype.fn = function () {
        return this.name;
    };

    var p = new Foo('xiaoming');


    // function 关键字省略 ， 方法之间不需要逗号分隔

    //es6定义类
    class Foo2 {
        constructor(name) {
            this.name = name;
            this.dish = [];
        }

        get menu() {
            return this.dish;
        }

        set menu(dish) {
            this.dish.push(dish)
        }

        fn() {
            return this.name;
        }

        sayHello() {
            console.log('hello ,xiao ming');
        }

        // 静态的方法
        static cook(food) {
            console.log(food);
        }
    }

    console.log(typeof Foo2); // "function"
    console.log(Foo2 === Foo2.prototype.constructor) // true

    // how to use
    var p2 = new Foo2('lao wang');
    console.log(p2.sayHello())
    console.log(p2.fn())

    console.log(p2.menu = 'xiao');
    console.log(p2.menu = 'ming');
    console.log(p2.menu); // ['xiao','ming']


    // 静态方法 不需要实例化 直接使用
    Foo2.cook('meat'); // meat


    class Person {
        constructor(name, birday) {
            this.name = name;
            this.birday = birday;
        }
        intro() {
            return `${this.name},${this.birday}`
        }
    }

    class chef extends Person {
        constructor(name, birday) {
            super(name, birday);
        }
    }

    let p = new chef('xiaoming', '1995-04-01');
    console.log(p.intro());

    // 类的方法都定义在prototype对象上,Object.assign方法可以很方便地一次向类添加多个方法
    class Point {
        constructor() {
            // ...
        }
    }
    Object.assign(Point.prototype, {
        toString() { },
        toValue() { }
    });

    Point.prototype.constructor === Point // true

    // 类的内部所有定义的方法，都是不可枚举的（non-enumerable）

    class Point {
        constructor(x, y) {
            // ...
        }

        toString() {
            // ...
        }
    }

    Object.keys(Point.prototype)
    // []
    Object.getOwnPropertyNames(Point.prototype)
    // ["constructor","toString"]



    var Point = function (x, y) {
        // ...
    };

    Point.prototype.toString = function () {
        // ...
    };

    Object.keys(Point.prototype)
    // ["toString"]
    Object.getOwnPropertyNames(Point.prototype)
    // ["constructor","toString"]


    //类的属性名，可以采用表达式
    let methodName = 'getArea';

    class Square {
        constructor(length) {
            // ...
        }

        [methodName]() {
            // ...
        }
    }

    // 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加
    // constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象
    class Foo {
        constructor() {
            return Object.create(null);
        }
    }

    new Foo() instanceof Foo // false


    // 类必须使用new调用，否则会报错

    //定义类
    class Point {

        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        toString() {
            return '(' + this.x + ', ' + this.y + ')';
        }

    }

    var point = new Point(2, 3);

    point.toString() // (2, 3)

    point.hasOwnProperty('x') // true
    point.hasOwnProperty('y') // true
    point.hasOwnProperty('toString') // false
    point.__proto__.hasOwnProperty('toString') // true

    // 类的所有实例共享一个原型对象

    var p1 = new Point(2, 3);
    var p2 = new Point(3, 2);

    p1.__proto__ === p2.__proto__ //true

    // Class 表达式
    // 类的名字是MyClass , Me只在 Class 的内部代码可用，指代当前类
    const MyClass = class Me {
        getClassName() {
            return Me.name;
        }
    };
    // 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式
    const MyClass = class { /* ... */ };

    // 采用 Class 表达式，可以写出立即执行的 Class
    let person = new class {
        constructor(name) {
            this.name = name;
        }

        sayName() {
            console.log(this.name);
        }
    }('张三');

    person.sayName(); // "张三"

    // 不存在变量提升
    new Foo(); // ReferenceError
    class Foo { }

    // 私有方法
    const bar = Symbol('bar');
    const snaf = Symbol('snaf');

    export default class myClass {

        // 公有方法
        foo(baz) {
            this[bar](baz);
        }

        // 私有方法
        [bar](baz) {
            return this[snaf] = baz;
        }

        // ...
    };


    //Class 的取值函数（getter）和存值函数（setter）
    class MyClass {
        constructor() {
            // ...
        }
        get prop() {
            return 'getter';
        }
        set prop(value) {
            console.log('setter: ' + value);
        }
    }

    let inst = new MyClass();

    inst.prop = 123;
    // setter: 123

    inst.prop
    // 'getter'

    // 存值函数和取值函数是设置在属性的 Descriptor 对象上的
    class CustomHTMLElement {
        constructor(element) {
            this.element = element;
        }

        get html() {
            return this.element.innerHTML;
        }

        set html(value) {
            this.element.innerHTML = value;
        }
    }

    var descriptor = Object.getOwnPropertyDescriptor(
        CustomHTMLElement.prototype, "html"
    );

    "get" in descriptor; // true
    "set" in descriptor; // true

    // Class 的 Generator 方法
    class Foo {
        constructor(...args) {
            this.args = args;
        }
        *[Symbol.iterator]() {
            for (let arg of this.args) {
                yield arg;
            }
        }
    }

    for (let x of new Foo('hello', 'world')) {
        console.log(x);
    }


    //Class 的静态方法
    class Foo {
        static classMethod() {
            return 'hello';
        }
    }

    Foo.classMethod() // 'hello'

    var foo = new Foo();
    foo.classMethod()
    // TypeError: foo.classMethod is not a function

    //如果静态方法包含this关键字，这个this指的是类，而不是实例。
    class Foo {
        static bar() {
            this.baz();
        }
        static baz() {
            console.log('hello');
        }
        baz() {
            console.log('world');
        }
    }

    Foo.bar() // hello


    // 父类的静态方法，可以被子类继承

    class Foo {
        static classMethod() {
            return 'hello';
        }
    }

    class Bar extends Foo { }

    Bar.classMethod() // 'hello'


    // 父类的静态方法，也会被子类继承
    // 静态方法也是可以从super对象上调用的

    class Foo {
        static classMethod() {
            return 'hello';
        }
    }

    class Bar extends Foo {
        static classMethod() {
            return super.classMethod() + ', too';
        }
    }

    Bar.classMethod() // "hello, too"

    // Class 的静态属性和实例属性

    // 类的静态属性
    class Foo { }

    Foo.prop = 1;
    Foo.prop // 1

    // 类的静态属性 新写法
    class Foo {
        static prop = 1;
    }

    // 类的实例属性
    class MyClass {
        myProp = 42;
        constructor() {
            console.log(this.myProp); // 42
        }
    }

    class ReactCounter extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                count: 0
            };
        }
    }

    class ReactCounter extends React.Component {
        state = {
            count: 0
        };
    }


    //new.target :如果构造函数不是通过new命令调用的，new.target会返回undefined
    function Person(name) {
        if (new.target !== undefined) {
            this.name = name;
        } else {
            throw new Error('必须使用 new 命令生成实例');
        }
    }

    // 另一种写法
    function Person(name) {
        if (new.target === Person) {
            this.name = name;
        } else {
            throw new Error('必须使用 new 命令生成实例');
        }
    }

    var person = new Person('张三'); // 正确
    var notAPerson = Person.call(person, '张三'); // 报错

    // Class 内部调用new.target，返回当前 Class
    class Rectangle {
        constructor(length, width) {
            console.log(new.target === Rectangle);
            this.length = length;
            this.width = width;
        }
    }

    var obj = new Rectangle(3, 4); // 输出 true

    // 子类继承父类时，new.target会返回子类
    class Rectangle {
        constructor(length, width) {
            console.log(new.target === Rectangle);
            // ...
        }
    }

    class Square extends Rectangle {
        constructor(length) {
            super(length, length);
        }
    }

    var obj = new Square(3); // 输出 false

    //写出不能独立使用、必须继承后才能使用的类
    class Shape {
        constructor() {
            if (new.target === Shape) {
                throw new Error('本类不能实例化');
            }
        }
    }

    class Rectangle extends Shape {
        constructor(length, width) {
            super();
            // ...
        }
    }

    var x = new Shape(); // 报错
    var y = new Rectangle(3, 4); // 正确

    // 在函数外部，使用new.target会报错

    /**
      calss继承 extends
    */
    // super关键字，它在这里表示父类的构造函数，用来新建父类的this对象
    // 子类必须在constructor方法中调用super方法，否则新建实例时会报错
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }
    class ColorPoint extends Point {
        constructor(x, y, color) {
            super(x, y); // 调用父类的constructor(x, y)
            this.color = color;
        }
        toString() {
            return this.color + ' ' + super.toString(); // 调用父类的toString()
        }
    }

    let cp = new ColorPoint(25, 8, 'green');

    cp instanceof ColorPoint // true
    cp instanceof Point // true

    // 父类的静态方法，也会被子类继承
    class A {
        static hello() {
            console.log('hello world');
        }
    }

    class B extends A { }

    B.hello() // hello world

    // Object.getPrototypeOf方法可以用来从子类上获取父类
    // 使用这个方法判断，一个类是否继承了另一个类
    Object.getPrototypeOf(ColorPoint) === Point // true


    // super 作为函数调用时，代表父类的构造函数
    class A { }

    class B extends A {
        constructor() {
            super();
        }
    }
    // super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B
    // 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错
    class A {
        constructor() {
            console.log(new.target.name);
        }
    }
    class B extends A {
        constructor() {
            super();
        }
    }
    new A() // A
    new B() // B

    // super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
    class A {
        p() {
            return 2;
        }
    }
    class B extends A {
        constructor() {
            super();
            console.log(super.p()); // 2
        }
    }
    let b = new B();

    // 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的
    class A {
        constructor() {
            this.p = 2;
        }
    }

    class B extends A {
        get m() {
            return super.p;
        }
    }
    let b = new B();
    b.m // undefined

    // 属性定义在父类的原型对象上，super就可以取到
    class A { }
    A.prototype.x = 2;

    class B extends A {
        constructor() {
            super();
            console.log(super.x) // 2
        }
    }

    let b = new B();

    // 通过super调用父类的方法时，方法内部的this指向子类
    class A {
        constructor() {
            this.x = 1;
        }
        print() {
            console.log(this.x);
        }
    }

    class B extends A {
        constructor() {
            super();
            this.x = 2;
        }
        m() {
            super.print();
        }
    }

    let b = new B();
    b.m() // 2

    // super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象
    class Parent {
        static myMethod(msg) {
            console.log('static', msg);
        }

        myMethod(msg) {
            console.log('instance', msg);
        }
    }

    class Child extends Parent {
        static myMethod(msg) {
            super.myMethod(msg);
        }

        myMethod(msg) {
            super.myMethod(msg);
        }
    }

    Child.myMethod(1); // static 1

    var child = new Child();
    child.myMethod(2); // instance 2

    // 类的 prototype 属性和__proto__属性
    class A { }

    class B extends A { }

    B.__proto__ === A // true
    B.prototype.__proto__ === A.prototype // true




</script>

</html>